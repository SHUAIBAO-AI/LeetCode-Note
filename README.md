# LeetCode-Note
LeetCode刷题记录与笔记

全部语言都是Python，便于理解


## 题目1
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。

示例 1：

输入：nums = [2,7,11,15], target = 9

输出：[0,1]

解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

### 思路：

方法一：
暴力破解
用两层循环进行解题，不过提交结果后提示 “超出时间限制”，这里就不做讲解。

方法二：
用 Python 中 list 的相关函数求解
解题关键主要是想找到 num2 = target - num1，是否也在 list 中，那么就需要运用以下两个方法：

num2 in nums，返回 True 说明有戏

nums.index(num2)，查找 num2 的索引

方法三：

解题思路是在方法二的基础上，优化解法。想着，num2 的查找并不需要每次从 nums 查找一遍，只需要从 num1 位置之前或之后查找即可。但为了方便 index 这里选择从 num1 位置之前查找：

方法四：

用字典模拟哈希求解
参考了大神们的解法，通过哈希来求解，这里通过字典来模拟哈希查询的过程。
个人理解这种办法相较于方法一其实就是字典记录了 num1 和 num2 的值和位置，而省了再查找 num2 索引的步骤。

通过字典的方法，查找效率快很多，执行速度大幅缩短，共 88ms。

方法四代码如下：
```Python
def twoSum(nums, target):
    hashmap={}
    for ind,num in enumerate(nums):
        hashmap[num] = ind
    for i,num in enumerate(nums):
        j = hashmap.get(target - num)
        if j is not None and i!=j:
            return [i,j]
```
### 笔记
什么是哈希表？
散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。
以上正式的解释摘自百度百科哈希表页面。
从这段解释中，我们理应知道的：
• 哈希表是一种数据结构
• 哈希表表示了关键码值和记录的映射关系
• 哈希表可以加快查找速度
• 任意哈希表，都满足有哈希函数f(key)，代入任意key值都可以获取包含该key值的记录在表中的地址

来自 <https://zhuanlan.zhihu.com/p/84327339> 
官方解释听过了，那么如何用大白话来解释呢？
简单的来说，哈希表是一种表结构，我们可以直接根据给定的key值计算出目标位置。在工程中这一表结构实现通常采用数组。
与普通的列表不同的地方在于，普通列表仅能通过下标来获取目标位置的值，而哈希表可以根据给定的key计算得到目标位置的值。
在列表查找中，使用最广泛的二分查找算法，复杂度为O(log2n)，但其始终只能用于有序列表。普通无序列表只能采用遍历查找，复杂度为O(n)。
而拥有较为理想的哈希函数实现的哈希表，对其任意元素的查找速度始终为常数级，即O(1)。

来自 <https://zhuanlan.zhihu.com/p/84327339> 


问题
Hash映射函数主要为取余函数
取余函数会导致可能有不同的数被映射到相同的位置上，比如523和23取余，都会映射到23这个位置上
解决方案：线性探测，拉链法

让我们回忆一下数据结构课程上的内容，当数据量比较大而且内存无法装下的时候，我们可以采用外排序的方法来进行排序，这里我们可以采用归并排序，因为归并排序有一个比较好的时间复杂度O(NlgN)。


外排序（External sorting）是指能够处理极大量数据的排序算法。通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。而后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。


## 题目2
两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例 1：

输入：l1 = [2,4,3], l2 = [5,6,4]

输出：[7,0,8]

解释：342 + 465 = 807.

提示：

每个链表中的节点数在范围 [1, 100] 内

0 <= Node.val <= 9

题目数据保证列表表示的数字不含前导零

### 思路：
方法：
方法代码如下：
```Python
```
### 笔记
链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。 每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。

比如，我们在数据集里面的一个表格，在展示上是连续的，有顺序的，但是在硬盘上是不连续的，没有顺序的
链表最显著的特征是：分散
链表中每个数据在储存中，都会有一个指针指向它的直接后继元素，也就是说，物理上的每个数据单元，都会在结尾有指针指向逻辑上的下一个元素
这样，这些由指针相连的数据直接就有了线性的关联

链表中数据的构成与概念

链表的数据有两部分：数据+指针
这个结构称为结点

n个结点通过指针相连
整个链表第一个结点称为首元结点
首元结点之前会有一个空结点，一般没数据，但是有时候也会有链表长度信息，这个空结点可有可无
链表也有增删查改的功能
删除B结点，假设数据为ABCD：此时我们要将A结点的指针直接指向C，尔后再释放掉B结点（一定要释放），然后就删掉了B结点
如果不释放B结点的数据，会造成内存泄漏
添加B结点，假设数据为ACD：此时我们要将A结点的指针指向B结点，B结点新增指针指向C结点

数组与链表的区别与优劣：
数组：
必须首先指定元素个数（定义长度），分配固定大小的空间，不能根据情况动态调整
数组从栈中分配空间，关于内存的申请与释放，都由系统完成，比较方便，但是自由度小
数组的插入与删除，都需要移动其后所有的元素，数组的效率低于链表
访问上，数组的内存是连续的，直接用下标访问数组元素，效率高于链表

链表：
不必指定元素个数，可以动态根据内存分配，很方便进行增减
链表从堆中分配空间，用多少就开多少内存，内存申请管理麻烦，但是自由度大
链表插入与删除，只需要修改指针，不需要移动节点，链表的效率高于数组
访问上，链表的内存是离散的，访问链表结点时，要从头结点开始查找，效率低于数组


结论是：
快速访加上少删插时，用数组
正常访问加多删插时，用链表
![image](https://user-images.githubusercontent.com/12431790/161229497-b5cc160a-cf5d-4ea4-9971-1970bc5bda15.png)



## 题目1
### 思路：
方法：
方法代码如下：
```Python
```
### 笔记
